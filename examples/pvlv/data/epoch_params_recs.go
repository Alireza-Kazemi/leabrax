// Code generated by "go run gen/reclistgen.go -type EpochParams -output data/epoch_params_recs.go". DO NOT EDIT

package data

import (
	"errors"
	"math/rand"
)

type EpochParamsList []*EpochParams

type EpochParamsRecs struct {
	Records EpochParamsList
	Index   []int
	INext   int
	NRead   int
	Order   DataLoopOrder
}

func NewEpochParamsRecs(data EpochParamsList) *EpochParamsRecs {
	recs := new(EpochParamsRecs)
	if data == nil {
		recs.Records = EpochParamsList{}
		recs.Index = []int{}
	} else {
		recs.Records = data
		recs.Index = IntSequence(0, len(data), 1)
	}
	recs.INext = -1
	recs.NRead = 0
	return recs
}

// Set to initial state just before reading
func (recs *EpochParamsRecs) Reset() {
	recs.NRead = 0
	recs.INext = -1
}

// Set the entire index array for the EpochParamsRecs
func (recs *EpochParamsRecs) SetIndex(ix []int) error {
	if len(ix) > len(recs.Records) {
		return errors.New("supplied index is longer than data")
	}
	recs.Index = ix
	recs.Reset()
	return nil
}

func (recs *EpochParamsRecs) SetPos(i int) {
	recs.INext = i - 1
}
func (recs *EpochParamsRecs) Length() int {
	return len(recs.Records)
}
func (recs *EpochParamsRecs) Cur() int {
	return recs.INext + 1
}

func (recs *EpochParamsRecs) SetOrder(order DataLoopOrder) {
	recs.Order = order
	if order == SEQUENTIAL {
		recs.Sequential()
	} else if order == PERMUTED {
		recs.Permute()
	}
	recs.Reset()
}

func (recs *EpochParamsRecs) Permute() {
	recs.Index = rand.Perm(len(recs.Records))
}
func (recs *EpochParamsRecs) Sequential() {
	recs.Index = IntSequence(0, len(recs.Records), 1)
}
func (recs *EpochParamsRecs) GetIndex() []int {
	return recs.Index
}
func (recs *EpochParamsRecs) WriteNext(rec *EpochParams) {
	recs.Records = append(recs.Records, rec)
	recs.Index = append(recs.Index, len(recs.Records)-1)
}
func (recs *EpochParamsRecs) ReadNext() *EpochParams {
	recs.NRead++
	if recs.Order == RANDOM {
		return recs.Records[rand.Intn(len(recs.Records))]
	} else {
		recs.INext++
		return recs.Records[recs.Index[recs.INext]]
	}
}

func (recs *EpochParamsRecs) Peek() *EpochParams {
	if recs.AtEnd() {
		return nil
	}
	return recs.Records[recs.Index[recs.INext+1]]
}
func (recs *EpochParamsRecs) AtEnd() bool {
	return recs.NRead >= len(recs.Records)
}
