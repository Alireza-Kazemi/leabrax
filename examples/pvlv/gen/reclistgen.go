package main

import (
	"flag"
	"fmt"
	"github.com/joncalhoun/pipe"
	"io"
	"os"
	"os/exec"
	"text/template"
)

// This is a workaround for the lack of generics in Go as of September 2020.
// Given a type name, this generator spits out a file that implements a RecordSet, basically a list of records of any type
// that can be accessed in sequential, permuted, or random order. Permuted order guarantees that each record will be visited
// once, random order may duplicate some records while skipping others altogether.
//
// For the current version of PVLV, two source files were generated using this. The commands used were:
// >go run cmd/gen/reclistgen.go -type TrialInstance >data/trial_instance_recs.go
// >go run cmd/gen/reclistgen.go -type EpochParams >data/epoch_params_recs.go
//
//

type data struct {
	Type    string
	Outfile string
}

func main() {
	var d data
	flag.StringVar(&d.Type, "type", "", "The name used for the datatype being generated. This should start with a capital letter so that it is exported")
	flag.StringVar(&d.Outfile, "output", "", "The name of the output file (a Go source file)")
	flag.Parse()
	outfile, err := os.Create(d.Outfile)
	if err != nil {
		fmt.Printf("error opening output file: %v\n", err)
		return
	}

	t := template.Must(template.New("reclist").Parse(recListTemplate))
	rc, wc, _ := pipe.Commands(
		exec.Command("gofmt"),
		exec.Command("goimports"), // imports do not need to be in the template because this generates them
	)
	err = t.Execute(wc, d)
	if err != nil {
		fmt.Printf("error in template execution: %v\n", err)
		return
	}
	err = wc.Close()
	if err != nil {
		fmt.Printf("error closing pipe: %v\n", err)
		return
	}
	_, err = io.Copy(outfile, rc)
	if err != nil {
		fmt.Printf("error copying stdout: %v\n", err)

	}
}

var recListTemplate = `
// Code generated by "go run gen/reclistgen.go -type {{.Type}} -output {{.Outfile}}". DO NOT EDIT

package data

type {{.Type}}List []*{{.Type}}

type {{.Type}}Recs struct {
	Records {{.Type}}List
	Index []int
	INext int
	NRead int
	Order DataLoopOrder
}

func New{{.Type}}Recs(data {{.Type}}List) *{{.Type}}Recs {
	recs := new({{.Type}}Recs)
	if data == nil {
		recs.Records = {{.Type}}List{}
		recs.Index = []int{}
	} else {
	recs.Records = data
	recs.Index = IntSequence(0, len(data), 1)
	}
	recs.INext = -1
	recs.NRead = 0
	return recs
}

// Set to initial state just before reading
func (recs *{{.Type}}Recs) Reset() {
	recs.NRead = 0
	recs.INext = -1
}

// Set the entire index array for the {{.Type}}Recs
func (recs *{{.Type}}Recs) SetIndex(ix []int) error {
	if len(ix) > len(recs.Records) {
		return errors.New("supplied index is longer than data")
	}
	recs.Index = ix
	recs.Reset()
	return nil
}

func (recs *{{.Type}}Recs) SetPos(i int) {
	recs.INext = i - 1
}
func (recs *{{.Type}}Recs) Length() int {
	return len(recs.Records)
}
func (recs *{{.Type}}Recs) Cur() int {
	return recs.INext + 1
}

func (recs *{{.Type}}Recs) SetOrder(order DataLoopOrder) {
	recs.Order = order
   if order == SEQUENTIAL {
       recs.Sequential()
   } else if order == PERMUTED {
       recs.Permute()
   }
   recs.Reset()
}

func (recs *{{.Type}}Recs) Permute() {
	recs.Index = rand.Perm(len(recs.Records))
}
func (recs *{{.Type}}Recs) Sequential() {
	recs.Index = IntSequence(0, len(recs.Records), 1)
}
func (recs *{{.Type}}Recs) GetIndex() []int {
	return recs.Index
}
func (recs *{{.Type}}Recs) WriteNext(rec *{{.Type}}) {
	recs.Records = append(recs.Records, rec)
	recs.Index = append(recs.Index, len(recs.Records) - 1)
}
func (recs *{{.Type}}Recs) ReadNext() *{{.Type}} {
	recs.NRead++
	if recs.Order == RANDOM {
		return recs.Records[rand.Intn(len(recs.Records))]
	} else {
		recs.INext++
		return recs.Records[recs.Index[recs.INext]]
	}
}

func (recs *{{.Type}}Recs) Peek() *{{.Type}} {
	if recs.AtEnd() { return nil }
	return recs.Records[recs.Index[recs.INext+1]]
}
func (recs *{{.Type}}Recs) AtEnd() bool {
	return recs.NRead >= len(recs.Records)
}
`
